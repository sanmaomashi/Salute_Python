# 程序控制

## 一、条件分支结构

### 1. 开发中的应用场景 

生活中的判断几乎是无所不在的，我们每天都在做各种各样的选择，如果这样？如果那样？……   

![001_未成年人禁止入内-w400](https://raw.githubusercontent.com/sanmaomashi/Salute_Python/main/img/43.jpg)

![002_火车站安检-w400](https://raw.githubusercontent.com/sanmaomashi/Salute_Python/main/img/44.jpg)

程序中的判断

![003_判断示意图-w600](https://raw.githubusercontent.com/sanmaomashi/Salute_Python/main/img/45.jpg)

```python
if 今天发工资:
  先还信用卡的钱
  if 有剩余:
    又可以happy了，O(∩_∩)O哈哈~
  else:
    噢，no。。。还的等30天
else:
  盼着发工资
```

判断的定义

- 如果 **条件满足**，才能做某件事情，
- 如果 **条件不满足**，就做另外一件事情，或者什么也不做

正是因为有了判断，才使得程序世界丰富多彩，充满变化！

判断语句 又被称为 “分支语句”，正是因为有了判断，才让程序有了很多的分支

### 2. if 语句

在 Python 中，if 语句就是用来进行判断的，格式如下：

```python
if 要判断的条件:
	条件成立时，要做的事情
	……
```

注意：代码的缩进为一个 tab 键，或者 4个空格 —— 建议使用空格

- 在 Python 开发中，Tab 和空格不要混用！

我们可以把整个 if 语句以及缩进部分看成一个完整的代码块

![004_if语句是一个完整的代码块1-w400](https://raw.githubusercontent.com/sanmaomashi/Salute_Python/main/img/46.jpg)

### 3. else 语句

在使用 `if` 判断时，只能做到满足条件时要做的事情。在 **不满足条件的时候**，就需要使用`else`语句来处理，格式如下：

```python
if 要判断的条件:
	条件成立时，要做的事情
  ……
else:
	条件不成立时，要做的事情
  ……
```

### 4. elif 语句

- 在开发中，使用 if 可以判断条件
- 使用 else 可以处理条件不成立的情况
- 但是，如果希望再增加一些条件，条件不同，需要执行的代码也不同时，就可以使用 elif
- 语法格式如下：

```python
if 条件1:
	条件1满足执行的代码
  	……
elif 条件2:
	条件2满足时，执行的代码
  	……
elif 条件3:
  	条件3满足时，执行的代码
 	……
else:
  	以上条件都不满足时，执行的代码
  	……
```

**注意**

1. `elif` 和 `else` 都必须和 `if` 联合使用，而不能单独使用
2. 可以将 `if`、`elif` 和 `else` 以及各自缩进的代码，看成一个 **完整的代码块**

### 5. if的嵌套

![002_火车站安检-w400](https://raw.githubusercontent.com/sanmaomashi/Salute_Python/main/img/47.jpg)

> elif 的应用场景是同时判断多个条件，所有的条件是平级的
>

- 在开发中，使用if进行条件判断，如果希望在条件成立的执行语句中再增加条件判断，就可以使用if的嵌套
- if 的嵌套的应用场景就是：在之前条件满足的前提下，再增加额外的判断
- if 的嵌套的语法格式，除了缩进之外和之前的没有区别
- 语法格式如下：

```python
if 条件 1:
    条件 1 满足执行的代码
    ……
    
    if 条件 1 基础上的条件 2:
        条件 2 满足时，执行的代码
        ……    
        
    # 条件 2 不满足的处理
    else:
        条件 2 不满足时，执行的代码
        
# 条件 1 不满足的处理
else:
    条件1 不满足时，执行的代码
    ……
```

### 6. 程序演练

#### 6.1 火车站安检

**需求**

a . 定义布尔型变量 `has_ticket` 表示是否有车票

b. 定义整型变量 `knife_length` 表示刀的长度，单位：厘米

c. 首先检查是否有车票，如果有，才允许进行 **安检**

d. 安检时，需要检查刀的长度，判断是否超过 20 厘米
* 如果超过 20 厘米，提示刀的长度，不允许上车
* 如果不超过 20 厘米，安检通过

e. 如果没有车票，不允许进门

```python
# 定义布尔型变量 has_ticket 表示是否有车票
has_ticket = True

# 定义整数型变量 knife_length 表示刀的长度，单位：厘米
knife_length = 20

# 首先检查是否有车票，如果有，才允许进行 安检
if has_ticket:
    print("有车票，可以开始安检...")

    # 安检时，需要检查刀的长度，判断是否超过 20 厘米
    # 如果超过 20 厘米，提示刀的长度，不允许上车
    if knife_length >= 20:
        print("不允许携带 %d 厘米长的刀上车" % knife_length)
    # 如果不超过 20 厘米，安检通过
    else:
        print("安检通过，祝您旅途愉快……")

# 如果没有车票，不允许进门
else:
    print("大哥，您要先买票啊")
```

#### 6.2 石头剪刀布

**需求**

1. 从控制台输入要出的拳 —— 石头（1）／剪刀（2）／布（3）
2. 电脑 **随机** 出拳 —— 先假定电脑只会出石头，完成整体代码功能
3. 比较胜负

| 序号 |     规则     |
| :--: | :----------: |
|  1   | 石头 胜 剪刀 |
|  2   |  剪刀 胜 布  |
|  3   |  布 胜 石头  |

实现如下：

* 先 **假定电脑就只会出石头**，完成整体代码功能

```python
# 从控制台输入要出的拳 —— 石头（1）／剪刀（2）／布（3）
player = int(input("请出拳 石头（1）／剪刀（2）／布（3）："))

# 电脑 随机 出拳 - 假定电脑永远出石头
computer = 1

# 比较胜负
# 如果条件判断的内容太长，可以在最外侧的条件增加一对大括号
# 再在每一个条件之间，使用回车，PyCharm 可以自动增加 8 个空格
if ((player == 1 and computer == 2) or
        (player == 2 and computer == 3) or
        (player == 3 and computer == 1)):

    print("噢耶！！！电脑弱爆了！！！")
elif player == computer:
    print("心有灵犀，再来一盘！")
else:
    print("不行，我要和你决战到天亮！")

```


## 二、循环结构

### 1. 程序的三大流程

在程序开发中，一共有三种流程方式：

- **顺序** —— 从上向下，顺序执行代码
- **分支** —— 根据条件判断，决定执行代码的分支
- **循环** —— 让特定代码重复执行        

![001_程序三大流程](https://raw.githubusercontent.com/sanmaomashi/Salute_Python/main/img/48.jpg)          

### 2.  Python 中的计数方法

常见的计数方法有两种，可以分别称为：

* **自然计数法**（从 `1` 开始）—— 更符合人类的习惯
* **程序计数法**（从 `0` 开始）—— 几乎所有的程序语言都选择从 0 开始计数

因此，在编写程序时，应该尽量养成习惯：**除非需求的特殊要求，否则 循环 的计数都从 0 开始**

### 3. while循环

- 循环的作用就是让指定的代码重复的执行

- while 循环最常用的应用场景就是让执行的代码按照指定的次数重复执行

**while语句基本语法**

初始条件设置 —— 通常是重复执行的 计数器

```python
while 条件(判断 计数器 是否达到 目标次数):
    条件满足时，做的事情1
    条件满足时，做的事情2
    条件满足时，做的事情3
    ...(省略)...
    处理条件(计数器 + 1)
```

**例子**：打印 5 遍 Hello Python

```while
# 1. 定义重复次数计数器
i = 1
# 2. 使用 while 判断条件
while i <= 5:
    # 要重复执行的代码
    print("Hello Python")

    # 处理计数器 i
    i = i + 1

print("循环结束后的 i = %d" % i)
```

> 注意：循环结束后，之前定义的计数器条件的数值是依旧存在的

**循环计算**

* 计算 0 ~ 100 之间所有数字的累计求和结果

```python
# 计算 0 ~ 100 之间所有数字的累计求和结果
# 0. 定义最终结果的变量
result = 0

# 1. 定义一个整数的变量记录循环的次数
i = 0

# 2. 开始循环
while i <= 100:
    print(i)

    # 每一次循环，都让 result 这个变量和 i 这个计数器相加
    result += i

    # 处理计数器
    i += 1

print("0~100之间的数字求和结果 = %d" % result)

```

* 计算 0 ~ 100 之间 所有 **偶数** 的累计求和结果

开发步骤

1. 编写循环 **确认** **要计算的数字**
2. 添加 **结果** 变量，在循环内部 **处理计算结果**

```python
# 0. 最终结果
result = 0

# 1. 计数器
i = 0

# 2. 开始循环
while i <= 100:

    # 判断偶数
    if i % 2 == 0:
        print(i)
        result += i

    # 处理计数器
    i += 1

print("0~100之间偶数求和结果 = %d" % result)
```

**注意**：

- while 语句以及缩进部分是一个完整的代码块

死循环:由于程序员的原因，忘记在循环内部修改循环的判断条件，导致循环持续执行，程序无法终止！

### 4. while循环嵌套

- while 嵌套就是：while 里面还有 while

```python
while 条件 1:
    条件满足时，做的事情1
    条件满足时，做的事情2
    条件满足时，做的事情3
    ...(省略)...
    while 条件 2:
        条件满足时，做的事情1
        条件满足时，做的事情2
        条件满足时，做的事情3
        ...(省略)...
        处理条件 2
    处理条件 1
```

例子：

**九九乘法表**

第 1 步：用嵌套打印小星星

**需求**

* 在控制台连续输出五行 `*`，每一行星号的数量依次递增

```
*
**
***
****
*****
```

* 使用字符串 * 打印

```python
# 1. 定义一个计数器变量，从数字1开始，循环会比较方便
row = 1

while row <= 5:

    print("*" * row)

    row += 1

```

第 2 步：使用循环嵌套打印小星星

**知识点** 对 `print` 函数的使用做一个增强

* 在默认情况下，`print` 函数输出内容之后，会自动在内容末尾增加换行
* 如果不希望末尾增加换行，可以在 `print` 函数输出内容的后面增加 `, end=""`
* 其中 `""` 中间可以指定 `print` 函数输出内容之后，继续希望显示的内容

* 语法格式如下：

```python
# 向控制台输出内容结束之后，不会换行
print("*", end="")

# 单纯的换行
print("")
```

> `end=""` 表示向控制台输出内容结束之后，不会换行

**假设** `Python` **没有提供** 字符串的 `*` 操作 **拼接字符串**

**需求**

* 在控制台连续输出五行 `*`，每一行星号的数量依次递增

```
*
**
***
****
*****
```

**开发步骤**

* 1> 完成 5 行内容的简单输出
* 2> 分析每行内部的 `*` 应该如何处理？
  * 每行显示的星星和当前所在的行数是一致的
  * 嵌套一个小的循环，专门处理每一行中 `列` 的星星显示  

```python
row = 1

while row <= 5:

    # 假设 python 没有提供字符串 * 操作
    # 在循环内部，再增加一个循环，实现每一行的 星星 打印
    col = 1

    while col <= row:
        print("*", end="")

        col += 1

    # 每一行星号输出完成后，再增加一个换行
    print("")

    row += 1

```

第 3 步： 九九乘法表

**需求** 输出 九九乘法表，格式如下：

```
1 * 1 = 1   
1 * 2 = 2   2 * 2 = 4   
1 * 3 = 3   2 * 3 = 6   3 * 3 = 9   
1 * 4 = 4   2 * 4 = 8   3 * 4 = 12  4 * 4 = 16  
1 * 5 = 5   2 * 5 = 10  3 * 5 = 15  4 * 5 = 20  5 * 5 = 25  
1 * 6 = 6   2 * 6 = 12  3 * 6 = 18  4 * 6 = 24  5 * 6 = 30  6 * 6 = 36  
1 * 7 = 7   2 * 7 = 14  3 * 7 = 21  4 * 7 = 28  5 * 7 = 35  6 * 7 = 42  7 * 7 = 49  
1 * 8 = 8   2 * 8 = 16  3 * 8 = 24  4 * 8 = 32  5 * 8 = 40  6 * 8 = 48  7 * 8 = 56  8 * 8 = 64  
1 * 9 = 9   2 * 9 = 18  3 * 9 = 27  4 * 9 = 36  5 * 9 = 45  6 * 9 = 54  7 * 9 = 63  8 * 9 = 72  9 * 9 = 81

```

**开发步骤**

* 1. 打印 9 行小星星

```
*
**
***
****
*****
******
*******
********
*********
```

* 2. 将每一个 `*` 替换成对应的行与列相乘

```python
# 定义起始行
row = 1

# 最大打印 9 行
while row <= 9:
    # 定义起始列
    col = 1

    # 最大打印 row 列
    while col <= row:

        # end = ""，表示输出结束后，不换行
        # "\t" 可以在控制台输出一个制表符，协助在输出文本时对齐
        print("%d * %d = %d" % (col, row, row * col), end="\t")

        # 列数 + 1
        col += 1

    # 一行打印完成的换行
    print("")

    # 行数 + 1
    row += 1

```

**字符串中的转义字符**

* `\t` 在控制台输出一个 **制表符**，协助在输出文本时 **垂直方向** 保持对齐
* `\n` 在控制台输出一个 **换行符**

> **制表符** 的功能是在不使用表格的情况下在 **垂直方向** 按列对齐文本

| 转义字符 | 描述       |
| -------- | ---------- |
| \\\\     | 反斜杠符号 |
| \\'      | 单引号     |
| \\"      | 双引号     |
| \n       | 换行       |
| \t       | 横向制表符 |
| \r       | 回车       |

### 5. break

break 是专门在循环中使用的关键字

`break` **某一条件满足时**，退出循环，不再执行后续重复的代码

break 只针对当前所在循环有效

- **在循环过程中**，如果 **某一个条件满足后**，**不** 再希望 **循环继续执行**，可以使用 `break` 退出循环

```python
i = 0

while i < 10:

    # break 某一条件满足时，退出循环，不再执行后续重复的代码
    # i == 3
    if i == 3:
        break

    print(i)

    i += 1

print("over")
```

> `break` 只针对当前所在循环有效

### 6. continue

- **在循环过程中**，如果 **某一个条件满足后**，**不**希望 **执行循环代码，但是又不希望退出循环**，可以使用 `continue`
- 也就是：在整个循环中，**只有某些条件**，不需要执行循环代码，而其他条件都需要执行

```python
i = 0
while i < 10:

    # 当 i == 7 时，不希望执行需要重复执行的代码
    if i == 7:
        # 在使用 continue 之前，同样应该修改计数器
        # 否则会出现死循环
        i += 1
        continue
    # 重复执行的代码
    print(i)

    i += 1

```

* 需要注意：使用 `continue` 时，**条件处理部分的代码，需要特别注意**，不小心会出现 **死循环**

> `continue` 只针对当前所在循环有效

### 7. for 循环

for循环是迭代式循环，for 遍历 被循环中的每一项内容，比如下面的代码，for会循环遍历range(10)中的每一个元素，即0， 1， 2， 3...9，语法如下：

```python
for i in range(10):
    缩进的代码块
```

说明：

- 其中i为迭代出来的一个个对象，i只是一个变量名，可以任意
- 关键字for 和 in是必须的
- range(10) 是一个被迭代的对象，只要能存多个值，他就可以被迭代，你直接写一个列表也是一样的
- 迭代循环可以理解被迭代的对象就是一个老母鸡，她肚子里有的是蛋，迭代出来的对象就是蛋

**range()**

1. **range的用法**

```python
for i in range(1, 10, 1):
    """
    range最多可以接收三个参数，第一个是起始位置，默认值为0，
    第二个是结束位置，无默认值，必须指定，
    第三个是步长，默认值为1，
    如果只传一个位置参数，那就是指的结束位置，
    如果传两个位置参数，第一个为起始位置，
    第二个为结束位置，
    range第一个能取到，最后一个取不到，顾头不顾尾
    """
    print(i)
```

**2. 自定义range**

```python
# 简易版本range，只能接收两个位置参数或者三个位置参数，起始位置没有默认值
def show_my_range(start, stop, step=1):
    n = start
    while n < stop:
        yield n
        n += step


for item in show_my_range(1, 10, 3):
    print(item)
```

### 8. else

循环可以和else配合使用，else下方缩进的代码指的是==当循环正常结束之后要执行的代码==。

#### 8.1 while...else

需求：女朋友生气了，要惩罚：连续说5遍“媳妇儿，我错了”，如果道歉正常完毕女朋友就原谅我了，这个程序怎么写？

``` python
i = 1
while i <= 5:
    print('媳妇儿，我错了')
    i += 1
print('媳妇儿原谅我了...')
```

> 思考： 这个print是不是没有循环也能执行？

> 语法

``` python
while 条件:
    条件成立重复执行的代码
else:
    循环正常结束之后要执行的代码
```

> 示例

``` python
i = 1
while i <= 5:
    print('媳妇儿，我错了')
    i += 1
else:
    print('媳妇原谅我了，真开心，哈哈哈哈')
```

![image-20190125111816497](https://raw.githubusercontent.com/sanmaomashi/Salute_Python/main/img/248.png)

> 退出循环的方式

需求：女朋友生气，要求道歉5遍：媳妇儿，我错了。道歉到第三遍的时候，媳妇埋怨这一遍说的不真诚，是不是就是要退出循环了？这个退出有两种可能性：

- 更生气，不打算原谅，也不需要道歉了，程序如何书写？
- 只一遍不真诚，可以忍受，继续下一遍道歉，程序如何书写？

1. break

``` python
i = 1
while i <= 5:
    if i == 3:
        print('这遍说的不真诚')
        break
    print('媳妇儿，我错了')
    i += 1
else:
    print('媳妇原谅我了，真开心，哈哈哈哈')
```

![image-20190125111952693](https://raw.githubusercontent.com/sanmaomashi/Salute_Python/main/img/247.png)

> 所谓else指的是循环正常结束之后要执行的代码，即如果是break终止循环的情况，else下方缩进的代码将不执行。

2. continue

``` python
i = 1
while i <= 5:
    if i == 3:
        print('这遍说的不真诚')
        i += 1
        continue
    print('媳妇儿，我错了')
    i += 1
else:
    print('媳妇原谅我了，真开心，哈哈哈哈')
```

![image-20190125112111170](https://raw.githubusercontent.com/sanmaomashi/Salute_Python/main/img/246.png)

> 因为continue是退出当前一次循环，继续下一次循环，所以该循环在continue控制下是可以正常结束的，当循环结束后，则执行了else缩进的代码。

#### 8.2 for...else

> 语法

``` python
for 临时变量 in 序列:
    重复执行的代码
    ...
else:
    循环正常结束之后要执行的代码
```

> 所谓else指的是循环正常结束之后要执行的代码，即如果是break终止循环的情况，else下方缩进的代码将不执行。

> 示例

``` python
str1 = 'itheima'
for i in str1:
    print(i)
else:
    print('循环正常结束之后执行的代码')
```

> 退出循环的方式

1. break终止循环

``` python
str1 = 'itheima'
for i in str1:
    if i == 'e':
        print('遇到e不打印')
        break
    print(i)
else:
    print('循环正常结束之后执行的代码')
```

执行结果：

![image-20190104165551501-6592151](https://raw.githubusercontent.com/sanmaomashi/Salute_Python/main/img/249.png)

> 没有执行else缩进的代码。

2. continue控制循环

``` python
str1 = 'itheima'
for i in str1:
    if i == 'e':
        print('遇到e不打印')
        continue
    print(i)
else:
    print('循环正常结束之后执行的代码')
```

执行结果：

![image-20190104165714740-6592234](https://raw.githubusercontent.com/sanmaomashi/Salute_Python/main/img/250.png)

> 因为continue是退出当前一次循环，继续下一次循环，所以该循环在continue控制下是可以正常结束的，当循环结束后，则执行了else缩进的代码。



## 三、注意事项

### 1. 避免多层分支嵌套

如果这篇文章只能删减成一句话就结束，那么那句话一定是“要竭尽所能的避免分支嵌套”。过深的分支嵌套是很多编程新手最容易犯的错误之一。假如有一位新手程序员写了很多层分支嵌套，那么你可能会看到一层又一层的大括号：`if: if: if: ... else: else: else: ...`俗称“嵌套 if 地狱（Nested If Statement Hell）”。如果能够避免的话，尽可能用其他的方式代替，这种多层嵌套非常不利于代码的可读性，尤其是当一个 if 分支下代码的量比较多的时候。

### 2. 封装那些过于复杂的逻辑判断

如果条件分支里的表达式过于复杂，出现了太多的 `not/and/or`，那么这段代码的可读性就会大打折扣，这时我们可以把他拆解，或者先用not 的形式取反，取反的意思即为原来值为True,not后为False，原来值为False,not后为True。

### 3. 留意不同分支下的重复代码

重复代码是代码质量的天敌，而条件分支语句又非常容易成为重复代码的重灾区。所以，当我们编写条件分支语句时，需要特别留意，不要生产不必要的重复代码。当你编写分支代码时，请额外关注由分支产生的重复代码块，如果可以简单的消灭它们，那就不要迟疑。

### 4. 使用“德摩根定律”

在做分支判断时，我们有时候会写成这样的代码：

```python
# 如果用户账户没有余额或者用户透支额度，拒绝用户购买
# 以下是伪代码
if not “有余额” or not “有透支额度”:
    print("拒绝用户购买")
```

第一眼看到代码时，是不是需要思考一会才能理解它想干嘛？这是因为上面的逻辑表达式里面出现了 2 个 `not` 和 1 个 `or`。而我们人类恰好不擅长处理过多的“否定”以及“或”这种逻辑关系。这个时候，就该 [德摩根定律](http://link.zhihu.com/?target=https%3A//zh.wikipedia.org/wiki/%E5%BE%B7%E6%91%A9%E6%A0%B9%E5%AE%9A%E5%BE%8B) 出场了。通俗的说，德摩根定律就是 `not A or not B` 等价于 `not (A and B)`。通过这样的转换，上面的代码可以改写成这样：

```python
if not (“有余额” and “有透支额度”):
    print("拒绝用户购买")
```

### 5. 在条件判断中使用 all() / any()

`all()` 和 `any()` 两个函数非常适合在条件判断中使用。这两个函数接受一个可迭代对象，返回一个布尔值，其中：

- `all(seq)`：仅当 `seq` 中所有对象都为布尔真时返回 `True`，否则返回 `False`
- `any(seq)`：只要 `seq` 中任何一个对象为布尔真就返回 `True`，否则返回 `False`

假如我们有下面这段代码：

```python
def all_numbers_gt_10(numbers):
    # 仅当序列中所有数字大于 10 时，返回 True
    if not numbers:  # 如果numbers为空，因为在这里numbers代表一个列表，[1, 2, 3...]这种格式
        # 在列表中，空列表[]为False,这行代码就用来判断numbers是否为空，为空就返回False
        return False
    for n in numbers:  # 遍历numbers中的每一个元素
        if n <= 10:
            return False  # 如果有元素小于等于10，该函数马上返回False
    return True  # 如果numbers列表中的所有元素都大于10，那么返回True
```

如果使用 `all()` 内建函数，再配合一个简单的生成器表达式，上面的代码可以写成这样：

```python
def all_numbers_gt_10_2(numbers):
   return bool(numbers) and all(n > 10 for n in numbers)
```

简单、高效，同时也没有损失可用性。

### 6. 使用 try/while/for 中 else 分支

让我们看看这个函数：

```python
def do_stuff():
   first_thing_successed = False
   try:
       do_the_first_thing()# 做第一件事
       first_thing_successed = True# 第一件事成功了，把标志位置为True
   except Exception as e: # 如果上面两行代码（try中的两行代码）有错误，第一件事没有成功，执行下面语句
       print("Error while calling do_some_thing")
       return
   # 仅当 first_thing 成功完成时，做第二件事
   if first_thing_successed:
       return do_the_second_thing()
```

在函数 `do_stuff` 中，我们希望只有当 `do_the_first_thing()` 成功调用后*（也就是不抛出任何异常）*，才继续做第二个函数调用。为了做到这一点，我们需要定义一个额外的变量 `first_thing_successed` 来作为标记。其实，我们可以用更简单的方法达到同样的效果：

```python
def do_stuff():
   try:
       do_the_first_thing()
   except Exception as e:
       print("Error while calling do_some_thing")
       return
   else:
       return do_the_second_thing()
```

在 `try` 语句块最后追加上 `else` 分支后，分支下的`do_the_second_thing()` 便只会在 try 下面的所有语句正常执行（也就是没有异常，没有 return、break 等）完成后执行。类似的，Python 里的 `for/while` 循环也支持添加 `else` 分支，它们表示：当循环使用的迭代对象被正常耗尽、或 while 循环使用的条件变量变为 False 后才执行 else 分支下的代码。

