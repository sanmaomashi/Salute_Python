

## 4. 进制转换

十进制 二进制0b、八进制0o、十六进制0x

|   ↓    |     2进制     |     8进制     |     10进制     |     16进制     |
| :----: | :-----------: | :-----------: | :------------: | :------------: |
| 2进制  |       -       | bin(int(n,8)) | bin(int(n,10)) | bin(int(n,16)) |
| 8进制  | oct(int(n,2)) |       -       | oct(int(n,10)) | oct(int(n,16)) |
| 10进制 |   int(n,2)    |   int(n,8)    |       -        |   int(n,16)    |
| 16进制 | hex(int(n,2)) | hex(int(n,8)) | hex(int(n,10)) |       -        |

`原理：python内置函数进行进制转换的原理是将读入的一个字符串(python默认读入的都是字符串形式)转为10进制，然后再用相关函数进行其他进制转换`

### 4.1 2进制转换成其他进制

**2进制转换成8进制：oct(int(n,2))**

```python
n=input()
print(oct(int(n,2)))
```

输入: 1010
输出: 0o12

**2进制转换成10进制：int(n,2)**

```python
n=input()
print(int(n,2))
```

输入：1010
输出：10

**2进制转换成16进制：hex(int(n,2))**

```python
n=input()
print(hex(int(n,2)))
```

输入：1010
输出：0xa

### 4.2 8进制转换成其他进制

**8进制转换成2进制：bin(int(n,8))**

```python
n=input()
print(bin(int(n,8)))
```

输入：1010
输出：0b1000001000

**8进制转换成10进制：int(n,8)**

```python
n=input()
print(int(n,8))
```

输入：1010
输出：520

**8进制转换成16进制：hex(int(n,16))**

```python
n=input()
print(hex(int(n,8)))
```

输入：1010
输出：0x208

### 4.3 10进制转换成其他进制

说明：10进制转换可以直接采取上述表格中的形式，读入字符串，先转换为10进制的数，再用函数进行操作转换成其他进制。
但同时可以这样操作，读入的时候直接进行强制类型转换操作，转为int类型(python中的int类型的数据就是10进制)

**10进制转换成2进制：bin(n)**

```python
n=int(input())
print(bin(n))
```

输入：10
输出：0b1010

**10进制转换成8进制：oct(n)**

```python
n=int(input())
print(oct(n))
```

输入：10
输出：0o12

**10进制转换成16进制：hex(n)**

```python
n=int(input())
print(hex(n))
```

输入：10
输出：0xa

### 4.4 16进制转换成其他进制

**16进制转换成2进制：bin(int(n,16))**

```python
n=input()
print(bin(int(n,16)))
```

输入：a
输出：0b1010

**16进制转换成8进制：oct(int(n,16))**

```python
n=input()
print(oct(int(n,16)))
```

输入：a
输出：0o12

**16进制转换成10进制：int(n,16)**

```python
n=input()
print((int(n,16)))
```

输入：a
输出：10

**注意**：我们可以发现，除了转换成10进制的数，其他的进制转换结果都带有前缀，2进制是0b，8进制是0o，16进制是0x。但是我们在绝大部分使用进制转换后的数据时，是不需要它的前缀的。

### 4.5 使用字符串切片操作去掉前缀

**原理**：就是将进制转换后得到的结果对其进行字符串切片操作，将得到的结果从第三个字符开始取结果即可，这样我们可以得到不带前缀的结果

**举例：**

```python
//10进制转换成2进制
n=int(input())
print(bin(n)[2:])//切片操作
```

输入：10
输出：1010

```python
//10进制转换成8进制
n=int(input())
print(oct(n)[2:])//切片操作
```

输入：10
输出：12

```python
//10进制转换成16进制
n=int(input())
print(hex(n)[2:])//切片操作
```

输入：10
输出：a

其他的情况类比即可。

### 4.6 使用format函数进行格式化数字操作去掉前缀

**说明**：前面说过，不同类型的进制转换的原理时先转换为十进制，然后再用相关的函数进行进制转换操作，而format函数里面有格式化数字的方法可以直接实现进制转换的功能，下面一一介绍：

**其他类型转换为2进制：**
**操作**：在format函数的槽中添加一个b 即可实现其他类型对2进制的转换，下面举例说明

```python
n=input()
print("{:b}".format(int(n,8)))
//先将8进制的数转换为10进制，
//然后在format的槽中添加一个b，等价于实现了bin函数的功能
//但是此结果是不带有0b前缀的
```

输入：1010
输出：1000001000

**其他类型转换为8进制：**

**操作**：在format函数的槽中添加一个o 即可实现其他类型对8进制的转换，下面举例说明

```python
n=input()
print("{:o}".format(int(n,16)))
//先将一个16进制数转换为10进制
//然后利用format函数格式化数字方法转换即可
```

输入：a
输出：12

**其他类型转换为16进制：**
**操作**：在format函数的槽中添加一个x 即可实现其他类型对2进制的转换，下面举例说明

```python
n=input()
print("{:x}".format(int(n,8)))
//先将一个8进制的数转换为16进制
//然后原理同上
```

输入：1010
输出：208

注意：由于转换成10进制本来就是不带前缀的，无需用format格式化数字方法控制

## 5. 单位转换

8 bit == 1bytes

1024bytes==kb

1024kb==1MB

1024MB==1GB

1024GB==1TB

1024TB==1PB



# 四、编码方式

## 1. 字符编码说明

字符编码这个知识点其实只是涉及到一行代码，但是它非常重要，据不完全统计，现在软件30%的损失都是由于乱码问题所导致的，这个问题是最容易被大家所忽视的，因为使用的时候只是一行代码的问题，但是它的里面包含很多的知识，大部分人更加倾向于直接掌握结果，而不考虑它内部的知识，这就导致了一旦遇到字符编码的乱码问题，就会手足无措。你之前可能看过一些相关的介绍，正确与否我们先不做评论，在这篇文章中，我们会对字符编码进行全方位的介绍。字符编码的特点是理论非常多，而结论非常少，但是如果不知道理论，结论可能永远也无法理解，而且以后遇到字符编码问题就会不知所措。

## 2. 编码种类

### 2.1 ASCII

最初版本的密码本：所有的英文字母，数字，特殊字符。

ASCII编码用单字节表示字符，最高位固定为0，故最多只能表示128个字符，当编程只涉及到英文字符或数字时，不涉及中文字符时，可以使用ASCII编码。

ASCII最左边为0，为当时设计师预留的一位，设计师认为七位足可以表示英文+数字+特殊字符

### 2.2 unicode

万国码，将所有国家的语言文字都写入这个密码本

在文本文件中，看到的所有字符，包括中文，都需要在计算机中存储，而计算机只能存储0和1这样的二进制位，所以需要一种方法，将字符映射成数字，然后将数字转化为二进制位存储在计算机中。针对字符和数字的映射的问题，产生了unicode编码。

unicode将世界上的所有字符映射为唯一的数字。unicode数字并不是直接就可以转化为二进制存储，比如假设中文字符‘中’映射为数字1（00000001），‘国’映射为数字2（00000010），由于汉字很多，单字节并不能表示完所有的汉字，故可能会有汉字的unicode数字为258（00000001 00000010），假设为‘京’，现在在字符串中碰到存储为00000001 00000010的二进制串，不能区分出其实际代表的是“中国”还是“京”。

### 2.3 UTF-8

最少用8位表示一个字符

和GB系列不同，UTF-8可以将全世界所有的unicode数字表示出来。`UTF-8兼容ASCII编码，不兼容GB系列编码`，因此，若文本中UTF-8和GB系列编码混用，会出现乱码问题。UTF-8对于每个字符的存储，用最高二进制位开始连续1的个数表示字的长度，最高位为0表示单字节，用来兼容ASCII字符，为110表示双字节，非字符首字节的字节都以10开始，如下表格所示。例如：字符‘中’的unicode编码为2D4E(00101101 01001110),用UTF-8存储的二进制为E4B8AD(11100100 10111000 10101101 )，存储在计算机中的首字节为1110开头，表示此字符占三个字节，去掉开始字节表示长度的1110和其余字节开头的10，可以得到01001110 00101101(4E2D)，可以看到和unicode数字刚好相反，是因为是大端存储方式，高字节存储在内存中的低地址端，反过来即为unicode编码。

### 2.4 GBK

国标，只包含中文，英文（英文，数字，特殊字符）

GB(GuoBiao)为国标，GBK(GuoBiao Kuozhan)表示国标扩展。GB2312兼容ASCII编码，对于ASCII可以表示的字符，如英文字符‘A’、‘B’等，在GB2312中的编码和ASCII编码一致，占一个字节，对于ASCII不能表示的字符，GB2312用两个字节表示，且最高位不为0，以防和ASCII字符冲突。例如：‘A’在GB2312中存储的字节十六进制为41，在ASCII中也是41，中文字符‘中’在GB2312中存储的两个字节十六进制为D6D0，最高位为1不为0。

GB2312只有6763个汉字，而汉字特别多。GBK属于GB2312的扩展，增加了很多汉字，同时兼容GB2312，同样用两个字节表示非ASCII字符。

##  3. 字节码

Pyc文件：C 是 compiled编译过的意思

1. 浏览程序目录会发现一个 pycache 的目录

2. 目录下会有一个 .cpython-35.pyc 文件，cpython-35 表示 Python 解释器的版本

3. 这个 pyc 文件是由 Python解释器将 模块的源码转换为字节码

4. Python 这样保存字节码是作为一种启动速度的优化

**字节码**

- Python在解释源程序时是分成两个步骤的
- 1. 首先处理源代码，编译生成一个二进制字节码
  2. 再对字节码进行处理，才会生成 CPU 能够识别的机器码
- 有了模块的字节码文件之后，下一次运行程序时，如果在上次保存字节码之后没有修改过源代码，Python 将会加载 .pyc 文件并跳过编译这个步骤
- 当 Python 重编译时，它会自动检查源文件和字节码文件的时间戳
- 如果你又修改了源代码，下次程序运行时，字节码将自动重新创建

## 4. 文件头

Python 2.x 默认使用 `ASCII` 编码格式
Python 3.x 默认使用 `UTF-8` 编码格式

注意：既然是文件头，那么自然是要放在文件顶部，这也是开发规范的一些细节

- 通常使用以下代码指定解释器

```python
#!/usr/bin/env python  
```

- 在 Python 2.x 文件的第一行增加以下代码指定文件字符编码，解释器会以 `utf-8` 编码来处理 python 文件

```python
# *-* coding:utf8 *-*
```

这方式是官方推荐使用的！

- 也可以使用

```python
# coding=utf8
```

如果每次写代码我们都自己去写的话有点浪费时间，我们可以自己先在Pycharm上面配置好，以后每次新建一个文件自动就会添加文件头。MacOS系统的用户可以按照先点击Pycharm左上角按照：Pycharm--Preferences--Editor--File and Code Templates--Python Script 的顺序找到一块空白的区域，把以下代码粘贴进去，Windows系统的用户可以按照：File--Settings--Editor--File and Code Templates--Python Script，执行同样的操作。注意：作者那一行代码可以改成你自己的名字。

```python
#!/usr/bin/env python
# -*- coding: utf-8 -*-
# @Time    : ${DATE} ${TIME}
# @Author  : Albert  
# @File    : ${NAME}.py
```



## 5. 乱码问题的产生与解决

### 5.1 乱码问题的成因



内存中的编码都是Unicode，如果忽略硬盘，在内存中随便写什么编码都不会出现乱码，但是因为硬盘的存在就会出现由内存向硬盘保存的时候你要指定一个字符编码，比如说是GBK，这时就是由Unicode转化成GBK，当把这个硬盘文件重新在内存读取的时候你也要告诉计算机按照GBK编码来读取，它才会对应的把数据由GBK编码反解成Unicode编码写入到内存。如果你在这时告诉你计算机用ASCII的标准来反解数据，那么就无法反解出原来保存的数据内容，计算机懵圈了，呈现给你的就是它懵圈后的结果。

### 5.2 保证不乱码的方案

保证不出现乱码问题其实结论就只有一个：文件用什么编码保存的，就用什么编码读取，注意：我们能控制的只是文件由内存保存到硬盘的编码。

编写python程序时，为避免不同类型字符串混用出现编解码异常，要把编码和解码操作放在程序的最外围来做，程序的核心逻辑统一使用unicode字符类型。













# 四、代码块和小数据池

## 1. 代码块

Python程序是由代码块构造的。块是一个python程序的文本，他是作为一个单元执行的。

代码块：一个模块，一个函数，一个类，一个文件等都是一个代码块。

而作为交互方式输入的每个命令都是一个代码块。

如果在同一代码块下，则采用同一代码块下的缓存机制。

- 代码块的缓存机制

`前提条件：在同一个代码块内。`

机制内容：Python在执行同一个代码块的初始化对象的命令时，会检查是否其值是否已经存在，如果存在，会将其重用。换句话说：执行同一个代码块时，遇到初始化对象的命令时，他会将初始化的这个变量与值存储在一个字典中，在遇到新的变量时，会先在字典中查询记录，如果有同样的记录那么它会重复使用这个字典中的之前的这个值。文件执行时（同一个代码块）会把i1、i2两个变量指向同一个对象，满足缓存机制则他们在内存中只存在一个，即：id相同。

适用对象： int（float），str，bool。

对象的具体细则：

　　int(float):任何数字在同一代码块下都会复用。

　　bool:True和False在字典中会以1，0方式存在，并且复用。

　　str：几乎所有的字符串都会符合缓存机制，具体规定如下：

1.非乘法得到的字符串都满足代码块的缓存机制：

```python
s1 = '太白@！#*ewq'
s2 = '太白@！#*ewq'
print(s1 is s2)  # True
```

2.乘法得到的字符串分两种情况：

2.1 乘数为1时，任何字符串满足代码块的缓存机制：

```python
b1 = '太白@5847395QQ0743895*&^%$#((&_+(())' *1
a1 = '太白@5847395QQ0743895*&^%$#((&_+(())' *1
print(a1 is b1)  # True
```

2.2 乘数>=2时：仅含大小写字母，数字，下划线，总长度<=20，满足代码块的缓存机制：

```python
s1 = 'old_' * 5
s2 = 'old_' * 5
print(s1 is s2)  # True
```

**优点**：能够提高一些字符串，整数处理任务在时间和空间上的性能；需要值相同的字符串，整数的时候，直接从‘字典’中取出复用，避免频繁的创建和销毁，提升效率，节约内存。

## 2. 小数据池

小数据池就是Python中一种提高效率的方式,也叫缓存机制，驻留机制。不同代码块的缓存机制，固定数据类型使用同一个内存地址 小数池 -- 支持: str,int,bool

如果是不同代码块，则采用小数据池的驻留机制。

`前提条件：在不同一个代码块内。`

机制内容：

​	Python自动将-5~256的整数进行了缓存，当你将这些整数赋值给变量时，并不会重新创建对象，而是使用已经创建好的缓存对象。

python会将一定规则的字符串在字符串驻留池中，创建一份，当你将这些字符串赋值给变量时，并不会重新创建对象， 而是使用在字符串驻留池中创建好的对象。

其实，无论是缓存还是字符串驻留池，都是python做的一个优化，就是将~5-256的整数，和一定规则的字符串，放在一个‘池’（容器，或者字典）中，无论程序中那些变量指向这些范围内的整数或者字符串，那么他直接在这个‘池’中引用，言外之意，就是内存之中创建一个。

适用对象： int（float），str，bool

对象的具体细则：

**int**：那么大家都知道对于整数来说，小数据池的范围是-5~256 ，如果多个变量都是指向同一个（在这个范围内的）数字，他们在内存中指向的都是一个内存地址。

![988316-20180808200847930-504994378](https://gitee.com/zgf1366/pic_store/raw/master/img/20210120150223.png)

**str:**字符串要从下面这几个大方向讨论：

1.字符串的长度为0或者1，默认都采用了驻留机制（小数据池）。

![988316-20180808201330161-1470862471](https://gitee.com/zgf1366/pic_store/raw/master/img/20210120150239.png)

![img](https://gitee.com/zgf1366/pic_store/raw/master/img/20210120150414.png)

2.字符串的长度>1,且只含有大小写字母，数字，下划线时，才会默认驻留。

![988316-20180808201628603-631716317](https://gitee.com/zgf1366/pic_store/raw/master/img/20210120150433.png)

3.用乘法得到的字符串，分两种情况。

3.1 乘数为1时：

仅含大小写字母，数字，下划线，默认驻留。

![988316-20180808202136263-972264368](https://gitee.com/zgf1366/pic_store/raw/master/img/20210120150449.png)

含其他字符，长度<=1,默认驻留。

![988316-20180808202316229-779316774](https://gitee.com/zgf1366/pic_store/raw/master/img/20210120150515.png)

含其他字符，长度>1,默认驻留。

![988316-20180808202425137-1836179125](https://gitee.com/zgf1366/pic_store/raw/master/img/20210120150532.png)

3.2 乘数>=2时：

仅含大小写字母，数字，下划线，总长度<=20,默认驻留。

![988316-20180808202839323-1987776954](https://gitee.com/zgf1366/pic_store/raw/master/img/20210120150546.png)

4. 指定驻留

```python
from sys import intern
a = intern('hello!@'*20)
b = intern('hello!@'*20)
print(a is b)
#指定驻留是你可以指定任意的字符串加入到小数据池中，让其只在内存中创建一个对象，多个变量都是指向这一个字符串。
```

满足以上字符串的规则时，就符合小数据池的概念。

bool值就是True，False，无论你创建多少个变量指向True，False，那么他在内存中只存在一个。

看一下用了小数据池（驻留机制）的效率有多高：

显而易见，节省大量内存在字符串比较时，非驻留比较效率o(n)，驻留时比较效率o(1)。

![20180405084648_2eb605762effbc71c9f74d3e6410b761_2](https://gitee.com/zgf1366/pic_store/raw/master/img/20210120150606.jpeg)

优点：能够提高一些字符串，整数处理任务在时间和空间上的性能；需要值相同的字符串，整数的时候，直接从‘池’里拿来用，避免频繁的创建和销毁，提升效率，节约内存